module BACnet;

#import Bro;

# This module implements a BACnet parser.
#
# When used on IP, BACnet is a protocol, which is layered on top
# of UDP.
# When used with IP, the outmost layer of a BACnet packet is the
# BACnet Virtual Link Layer (BVLL), which supports a number of different
# Virtual Link Control Functions (BVLC).
#
# When the BVLL layer is used to sent a higher level message, it wraps
# a BACnet Network Protocol Data Unit (NPDU). This layer concerns itself
# with the routing (and so on) of BACnet messages. A NPDU message can either
# contain different NPDU Message Types, mostly concerning routing. A NPDU
# can also wrap a BACnet Application Protocol Data Unit (APDU).
#
# The APDU layer basically gets all messages that have nothing to do with routing.
# ASN.1 decoding is needed starting at this layer.

# vim search-replace for enums: s/^\(.*\) (\(\d*\).*/  \1 = \2,/

# List autogenerated by bacnet_parse_vendorIDs.pl
export type BACnetVendorIDs = enum {
  ASHRAE = 0,
  NIST = 1,
  The_Trane_Company = 2,
  McQuay_International = 3,
  PolarSoft = 4,
  Johnson_Controls__Inc_ = 5,
  American_Auto-Matrix = 6,
  Siemens_Schweiz_AG__Formerly__Landis___Staefa_Division_Europe_ = 7,
  Delta_Controls = 8,
  Siemens_Schweiz_AG = 9,
  Schneider_Electric_1 = 10,
  TAC = 11,
  Orion_Analysis_Corporation = 12,
  Teletrol_Systems_Inc_ = 13,
  Cimetrics_Technology = 14,
  Cornell_University = 15,
  United_Technologies_Carrier = 16,
  Honeywell_Inc_ = 17,
  Alerton___Honeywell = 18,
  TAC_AB = 19,
  Hewlett-Packard_Company = 20,
  Dorsettes_Inc_ = 21,
  Siemens_Schweiz_AG__Formerly__Cerberus_AG_ = 22,
  York_Controls_Group = 23,
  Automated_Logic_Corporation = 24,
  CSI_Control_Systems_International = 25,
  Phoenix_Controls_Corporation = 26,
  Innovex_Technologies__Inc_ = 27,
  KMC_Controls__Inc_ = 28,
  Xn_Technologies__Inc_ = 29,
  Hyundai_Information_Technology_Co___Ltd_ = 30,
  Tokimec_Inc_ = 31,
  Simplex = 32,
  North_Building_Technologies_Limited = 33,
  Notifier = 34,
  Reliable_Controls_Corporation = 35,
  Tridium_Inc_ = 36,
  Sierra_Monitor_Corporation_FieldServer_Technologies = 37,
  Silicon_Energy = 38,
  Kieback___Peter_GmbH___Co_KG = 39,
  Anacon_Systems__Inc_ = 40,
  Systems_Controls___Instruments__LLC = 41,
  Lithonia_Lighting = 42,
  Micropower_Manufacturing = 43,
  Matrix_Controls = 44,
  METALAIRE = 45,
  ESS_Engineering = 46,
  Sphere_Systems_Pty_Ltd_ = 47,
  Walker_Technologies_Corporation = 48,
  H_I_Solutions__Inc_ = 49,
  MBS_GmbH = 50,
  SAMSON_AG = 51,
  Badger_Meter_Inc_ = 52,
  DAIKIN_Industries_Ltd_ = 53,
  NARA_Controls_Inc_ = 54,
  Mammoth_Inc_ = 55,
  Liebert_Corporation = 56,
  SEMCO_Incorporated = 57,
  Air_Monitor_Corporation_1 = 58,
  TRIATEK__LLC = 59,
  NexLight = 60,
  Multistack = 61,
  TSI_Incorporated = 62,
  Weather-Rite__Inc_ = 63,
  Dunham-Bush = 64,
  Reliance_Electric = 65,
  LCS_Inc_ = 66,
  Regulator_Australia_PTY_Ltd_ = 67,
  Touch-Plate_Lighting_Controls = 68,
  Amann_GmbH = 69,
  RLE_Technologies = 70,
  Cardkey_Systems = 71,
  SECOM_Co___Ltd_ = 72,
  ABB_Gebudetechnik_AG_Bereich_NetServ = 73,
  KNX_Association_cvba = 74,
  Institute_of_Electrical_Installation_Engineers_of_Japan__IEIEJ_ = 75,
  Nohmi_Bosai__Ltd_ = 76,
  Carel_S_p_A_ = 77,
  AirSense_Technology__Inc_ = 78,
  Hochiki_Corporation = 79,
  Fr__Sauter_AG = 80,
  Matsushita_Electric_Works__Ltd_ = 81,
  Mitsubishi_Electric_Corporation__Inazawa_Works = 82,
  Mitsubishi_Heavy_Industries__Ltd_ = 83,
  ITT_Bell___Gossett = 84,
  Yamatake_Building_Systems_Co___Ltd_ = 85,
  The_Watt_Stopper__Inc_ = 86,
  Aichi_Tokei_Denki_Co___Ltd_ = 87,
  Activation_Technologies__LLC = 88,
  Saia-Burgess_Controls__Ltd_ = 89,
  Hitachi__Ltd_ = 90,
  Novar_Corp__Trend_Control_Systems_Ltd_ = 91,
  Mitsubishi_Electric_Lighting_Corporation = 92,
  Argus_Control_Systems__Ltd_ = 93,
  Kyuki_Corporation = 94,
  Richards-Zeta_Building_Intelligence__Inc_ = 95,
  Scientech_R_D__Inc_ = 96,
  VCI_Controls__Inc_ = 97,
  Toshiba_Corporation = 98,
  Mitsubishi_Electric_Corporation_Air_Conditioning___Refrigeration_Systems_Works = 99,
  Custom_Mechanical_Equipment__LLC = 100,
  ClimateMaster = 101,
  ICP_Panel-Tec__Inc_ = 102,
  D-Tek_Controls = 103,
  NEC_Engineering__Ltd_ = 104,
  PRIVA_BV = 105,
  Meidensha_Corporation = 106,
  JCI_Systems_Integration_Services = 107,
  Freedom_Corporation = 108,
  Neuberger_Gebudeautomation_GmbH = 109,
  Sitronix = 110,
  Leviton_Manufacturing = 111,
  Fujitsu_Limited = 112,
  Emerson_Network_Power = 113,
  S__A__Armstrong__Ltd_ = 114,
  Visonet_AG = 115,
  M_M_Systems__Inc_ = 116,
  Custom_Software_Engineering = 117,
  Nittan_Company__Limited = 118,
  Elutions_Inc___Wizcon_Systems_SAS_ = 119,
  Pacom_Systems_Pty___Ltd_ = 120,
  Unico__Inc_ = 121,
  Ebtron__Inc_ = 122,
  Scada_Engine = 123,
  AC_Technology_Corporation = 124,
  Eagle_Technology = 125,
  Data_Aire__Inc_ = 126,
  ABB__Inc_ = 127,
  Transbit_Sp__z_o__o_ = 128,
  Toshiba_Carrier_Corporation = 129,
  Shenzhen_Junzhi_Hi-Tech_Co___Ltd_ = 130,
  Tokai_Soft = 131,
  Blue_Ridge_Technologies = 132,
  Veris_Industries = 133,
  Centaurus_Prime = 134,
  Sand_Network_Systems = 135,
  Regulvar__Inc_ = 136,
  AFDtek_Division_of_Fastek_International_Inc_ = 137,
  PowerCold_Comfort_Air_Solutions__Inc_ = 138,
  I_Controls = 139,
  Viconics_Electronics__Inc_ = 140,
  Yaskawa_America__Inc_ = 141,
  DEOS_control_systems_GmbH = 142,
  Digitale_Mess-_und_Steuersysteme_AG = 143,
  Fujitsu_General_Limited = 144,
  Project_Engineering_S_r_l_ = 145,
  Sanyo_Electric_Co___Ltd_ = 146,
  Integrated_Information_Systems__Inc_ = 147,
  Temco_Controls__Ltd_ = 148,
  Airtek_International_Inc_ = 149,
  Advantech_Corporation = 150,
  Titan_Products__Ltd_ = 151,
  Regel_Partners = 152,
  National_Environmental_Product = 153,
  Unitec_Corporation = 154,
  Kanden_Engineering_Company = 155,
  Messner_Gebudetechnik_GmbH = 156,
  Integrated_CH = 157,
  Price_Industries = 158,
  SE-Elektronic_GmbH = 159,
  Rockwell_Automation = 160,
  Enflex_Corp_ = 161,
  ASI_Controls = 162,
  SysMik_GmbH_Dresden = 163,
  HSC_Regelungstechnik_GmbH = 164,
  Smart_Temp_Australia_Pty___Ltd_ = 165,
  Cooper_Controls = 166,
  Duksan_Mecasys_Co___Ltd_ = 167,
  Fuji_IT_Co___Ltd_ = 168,
  Vacon_Plc = 169,
  Leader_Controls = 170,
  Cylon_Controls__Ltd_ = 171,
  Compas = 172,
  Mitsubishi_Electric_Building_Techno-Service_Co___Ltd_ = 173,
  Building_Control_Integrators = 174,
  ITG_Worldwide__M__Sdn_Bhd = 175,
  Lutron_Electronics_Co___Inc_ = 176,
  LOYTEC_Electronics_GmbH = 178,
  ProLon = 179,
  Mega_Controls_Limited = 180,
  Micro_Control_Systems__Inc_ = 181,
  Kiyon__Inc_ = 182,
  Dust_Networks = 183,
  Advanced_Building_Automation_Systems = 184,
  Hermos_AG = 185,
  CEZIM = 186,
  Softing = 187,
  Lynxspring = 188,
  Schneider_Toshiba_Inverter_Europe = 189,
  Danfoss_Drives_A_S = 190,
  Eaton_Corporation = 191,
  Matyca_S_A_ = 192,
  Botech_AB = 193,
  Noveo__Inc_ = 194,
  AMEV = 195,
  Yokogawa_Electric_Corporation = 196,
  GFR_Gesellschaft_fr_Regelungstechnik = 197,
  Exact_Logic = 198,
  Mass_Electronics_Pty_Ltd_dba_Innotech_Control_Systems_Australia = 199,
  Kandenko_Co___Ltd_ = 200,
  DTF__Daten-Technik_Fries = 201,
  Klimasoft__Ltd_ = 202,
  Toshiba_Schneider_Inverter_Corporation = 203,
  Control_Applications__Ltd_ = 204,
  KDT_Systems_Co___Ltd_ = 205,
  Onicon_Incorporated = 206,
  Automation_Displays__Inc_ = 207,
  Control_Solutions__Inc_ = 208,
  Remsdaq_Limited = 209,
  NTT_Facilities__Inc_ = 210,
  VIPA_GmbH = 211,
  TSC21_Association_of_Japan = 212,
  Strato_Automation = 213,
  HRW_Limited = 214,
  Lighting_Control___Design__Inc_ = 215,
  Mercy_Electronic_and_Electrical_Industries = 216,
  Samsung_SDS_Co___Ltd = 217,
  Impact_Facility_Solutions__Inc_ = 218,
  Aircuity = 219,
  Control_Techniques__Ltd_ = 220,
  OpenGeneral_Pty___Ltd_ = 221,
  WAGO_Kontakttechnik_GmbH___Co__KG = 222,
  Cerus_Industrial = 223,
  Chloride_Power_Protection_Company = 224,
  Computrols__Inc_ = 225,
  Phoenix_Contact_GmbH___Co__KG = 226,
  Grundfos_Management_A_S = 227,
  Ridder_Drive_Systems = 228,
  Soft_Device_SDN_BHD = 229,
  Integrated_Control_Technology_Limited = 230,
  AIRxpert_Systems__Inc_ = 231,
  Microtrol_Limited = 232,
  Red_Lion_Controls = 233,
  Digital_Electronics_Corporation = 234,
  Ennovatis_GmbH = 235,
  Serotonin_Software_Technologies__Inc_ = 236,
  LS_Industrial_Systems_Co___Ltd_ = 237,
  Square_D_Company = 238,
  S_Squared_Innovations__Inc_ = 239,
  Aricent_Ltd_ = 240,
  EtherMetrics__LLC = 241,
  Industrial_Control_Communications__Inc_ = 242,
  Paragon_Controls__Inc_ = 243,
  A__O__Smith_Corporation = 244,
  Contemporary_Control_Systems__Inc_ = 245,
  Intesis_Software_SL = 246,
  Ingenieurgesellschaft_N__Hartleb_mbH = 247,
  Heat-Timer_Corporation = 248,
  Ingrasys_Technology__Inc_ = 249,
  Costerm_Building_Automation = 250,
  WILO_SE = 251,
  Embedia_Technologies_Corp_ = 252,
  Technilog = 253,
  HR_Controls_Ltd____Co__KG = 254,
  Lennox_International__Inc_ = 255,
  RK-Tec_Rauchklappen-Steuerungssysteme_GmbH___Co__KG = 256,
  Thermomax__Ltd_ = 257,
  ELCON_Electronic_Control__Ltd_ = 258,
  Larmia_Control_AB = 259,
  BACnet_Stack_at_SourceForge = 260,
  G4S_Security_Services_A_S = 261,
  Exor_International_S_p_A_ = 262,
  Cristal_Controles = 263,
  Regin_AB = 264,
  Dimension_Software__Inc__ = 265,
  SynapSense_Corporation = 266,
  Beijing_Nantree_Electronic_Co___Ltd_ = 267,
  Camus_Hydronics_Ltd_ = 268,
  Kawasaki_Heavy_Industries__Ltd__ = 269,
  Critical_Environment_Technologies = 270,
  ILSHIN_IBS_Co___Ltd_ = 271,
  ELESTA_Energy_Control_AG = 272,
  KROPMAN_Installatietechniek = 273,
  Baldor_Electric_Company = 274,
  INGA_mbH = 275,
  GE_Consumer___Industrial = 276,
  Functional_Devices__Inc_ = 277,
  ESAC = 278,
  M-System_Co___Ltd_ = 279,
  Yokota_Co___Ltd_ = 280,
  Hitranse_Technology_Co___LTD = 281,
  Federspiel_Controls = 282,
  Kele__Inc_ = 283,
  Opera_Electronics__Inc_ = 284,
  Gentec = 285,
  Embedded_Science_Labs__LLC = 286,
  Parker_Hannifin_Corporation = 287,
  MaCaPS_International_Limited = 288,
  Link4_Corporation = 289,
  Romutec_Steuer-u__Regelsysteme_GmbH_ = 290,
  Pribusin__Inc_ = 291,
  Advantage_Controls = 292,
  Critical_Room_Control = 293,
  LEGRAND = 294,
  Tongdy_Control_Technology_Co___Ltd__ = 295,
  ISSARO_Integrierte_Systemtechnik = 296,
  Pro-Dev_Industries = 297,
  DRI-STEEM = 298,
  Creative_Electronic_GmbH = 299,
  Swegon_AB = 300,
  Jan_Brachacek = 301,
  Hitachi_Appliances__Inc_ = 302,
  Real_Time_Automation__Inc_ = 303,
  ITEC_Hankyu-Hanshin_Co_ = 304,
  Cyrus_E_M_Engineering_Co___Ltd__ = 305,
  Racine_Federated__Inc_ = 306,
  Cirrascale_Corporation = 307,
  Elesta_GmbH_Building_Automation_ = 308,
  Securiton = 309,
  OSlsoft__Inc_ = 310,
  Hanazeder_Electronic_GmbH_ = 311,
  Honeywell_Security_Deutschland__Novar_GmbH = 312,
  Siemens_Energy___Automation__Inc_ = 313,
  ETM_Professional_Control_GmbH = 314,
  Meitav-tec__Ltd_ = 315,
  Janitza_Electronics_GmbH_ = 316,
  MKS_Nordhausen = 317,
  De_Gier_Drive_Systems_B_V__ = 318,
  Cypress_Envirosystems = 319,
  SMARTron_s_r_o_ = 320,
  Verari_Systems__Inc_ = 321,
  K-W_Electronic_Service__Inc_ = 322,
  ALFA-SMART_Energy_Management = 323,
  Telkonet__Inc_ = 324,
  Securiton_GmbH = 325,
  Cemtrex__Inc_ = 326,
  Performance_Technologies__Inc_ = 327,
  Xtralis__Aust__Pty_Ltd = 328,
  TROX_GmbH = 329,
  Beijing_Hysine_Technology_Co___Ltd = 330,
  RCK_Controls__Inc_ = 331,
  Distech_Controls_SAS = 332,
  Novar_Honeywell = 333,
  The_S4_Group__Inc_ = 334,
  Schneider_Electric_2 = 335,
  LHA_Systems = 336,
  GHM_engineering_Group__Inc_ = 337,
  Cllimalux_S_A_ = 338,
  VAISALA_Oyj = 339,
  COMPLEX__Beijing__Technology__Co___LTD_ = 340,
  SCADAmetrics = 341,
  POWERPEG_NSI_Limited = 342,
  BACnet_Interoperability_Testing_Services__Inc_ = 343,
  Teco_a_s_ = 344,
  Plexus_Technology__Inc_ = 345,
  Energy_Focus__Inc_ = 346,
  Powersmiths_International_Corp_ = 347,
  Nichibei_Co___Ltd_ = 348,
  HKC_Technology_Ltd_ = 349,
  Ovation_Networks__Inc_ = 350,
  Setra_Systems = 351,
  AVG_Automation = 352,
  ZXC_Ltd_ = 353,
  Byte_Sphere = 354,
  Generiton_Co___Ltd_ = 355,
  Holter_Regelarmaturen_GmbH___Co__KG = 356,
  Bedford_Instruments__LLC = 357,
  Standair_Inc_ = 358,
  WEG_Automation_-_R_D = 359,
  Prolon_Control_Systems_ApS = 360,
  Inneasoft = 361,
  ConneXSoft_GmbH = 362,
  CEAG_Notlichtsysteme_GmbH = 363,
  Distech_Controls_Inc_ = 364,
  Industrial_Technology_Research_Institute = 365,
  ICONICS__Inc_ = 366,
  IQ_Controls_s_c_ = 367,
  OJ_Electronics_A_S = 368,
  Rolbit_Ltd_ = 369,
  Synapsys_Solutions_Ltd_ = 370,
  ACME_Engineering_Prod__Ltd_ = 371,
  Zener_Electric_Pty__Ltd_ = 372,
  Selectronix__Inc_ = 373,
  Gorbet___Banerjee__LLC_ = 374,
  IME = 375,
  Stephen_H__Dawson_Computer_Service = 376,
  Accutrol__LLC = 377,
  Schneider_Elektronik_GmbH = 378,
  Alpha-Inno_Tec_GmbH = 379,
  ADMMicro__Inc_ = 380,
  Greystone_Energy_Systems__Inc_ = 381,
  CAP_Technologie = 382,
  KeRo_Systems = 383,
  Domat_Control_System_s_r_o_ = 384,
  Efektronics_Pty__Ltd_ = 385,
  Hekatron_Vertriebs_GmbH = 386,
  Securiton_AG = 387,
  Carlo_Gavazzi_Controls_SpA = 388,
  Chipkin_Automation_Systems = 389,
  Savant_Systems__LLC = 390,
  Simmtronic_Lighting_Controls = 391,
  Abelko_Innovation_AB = 392,
  Seresco_Technologies_Inc_ = 393,
  IT_Watchdogs = 394,
  Automation_Assist_Japan_Corp_ = 395,
  Thermokon_Sensortechnik_GmbH = 396,
  EGauge_Systems__LLC = 397,
  Quantum_Automation__ASIA__PTE__Ltd_ = 398,
  Toshiba_Lighting___Technology_Corp_ = 399,
  SPIN_Engenharia_de_Automao_Ltda_ = 400,
  Logistics_Systems___Software_Services_India_PVT__Ltd_ = 401,
  Delta_Controls_Integration_Products = 402,
  Focus_Media = 403,
  LUMEnergi_Inc_ = 404,
  Kara_Systems = 405,
  RF_Code__Inc_ = 406,
  Fatek_Automation_Corp_ = 407,
  JANDA_Software_Company__LLC = 408,
  Open_System_Solutions_Limited = 409,
  Intelec_Systems_PTY_Ltd_ = 410,
  Ecolodgix__LLC = 411,
  Douglas_Lighting_Controls = 412,
  iSAtech_GmbH = 413,
  AREAL = 414,
  Beckhoff_Automation_GmbH = 415,
  IPAS_GmbH = 416,
  KE2_Therm_Solutions = 417,
  Base2Products = 418,
  DTL_Controls__LLC = 419,
  INNCOM_International__Inc_ = 420,
  BTR_Netcom_GmbH = 421,
  Greentrol_Automation__Inc = 422,
  BELIMO_Automation_AG = 423,
  Samsung_Heavy_Industries_Co__Ltd = 424,
  Triacta_Power_Technologies__Inc_ = 425,
  Globestar_Systems = 426,
  MLB_Advanced_Media__LP = 427,
  SWG_Stuckmann_Wirtschaftliche_Gebudesysteme_GmbH = 428,
  SensorSwitch = 429,
  Multitek_Power_Limited = 430,
  Aquametro_AG = 431,
  LG_Electronics_Inc_ = 432,
  Electronic_Theatre_Controls__Inc_ = 433,
  Mitsubishi_Electric_Corporation_Nagoya_Works = 434,
  Delta_Electronics__Inc_ = 435,
  Elma_Kurtalj__Ltd_ = 436,
  ADT_Fire_and_Security_Sp__A_o_o_ = 437,
  Nedap_Security_Management = 438,
  ESC_Automation_Inc_ = 439,
  DSP4YOU_Ltd_ = 440,
  GE_Sensing_and_Inspection_Technologies = 441,
  Embedded_Systems_SIA = 442,
  BEFEGA_GmbH = 443,
  Baseline_Inc_ = 444,
  M2M_Systems_Integrators = 445,
  OEMCtrl = 446,
  Clarkson_Controls_Limited = 447,
  Rogerwell_Control_System_Limited = 448,
  SCL_Elements = 449,
  Hitachi_Ltd_ = 450,
  Newron_System_SA = 451,
  BEVECO_Gebouwautomatisering_BV = 452,
  Streamside_Solutions = 453,
  Yellowstone_Soft = 454,
  Oztech_Intelligent_Systems_Pty_Ltd_ = 455,
  Novelan_GmbH = 456,
  Flexim_Americas_Corporation = 457,
  ICP_DAS_Co___Ltd_ = 458,
  CARMA_Industries_Inc_ = 459,
  Log-One_Ltd_ = 460,
  TECO_Electric___Machinery_Co___Ltd_ = 461,
  ConnectEx__Inc_ = 462,
  Turbo_DDC_Sdwest = 463,
  Quatrosense_Environmental_Ltd_ = 464,
  Fifth_Light_Technology_Ltd_ = 465,
  Scientific_Solutions__Ltd_ = 466,
  Controller_Area_Network_Solutions__M__Sdn_Bhd = 467,
  RESOL_-_Elektronische_Regelungen_GmbH = 468,
  RPBUS_LLC = 469,
  BRS_Sistemas_Eletronicos = 470,
  WindowMaster_A_S = 471,
  Sunlux_Technologies_Ltd_ = 472,
  Measurlogic = 473,
  Frimat_GmbH = 474,
  Spirax_Sarco = 475,
  Luxtron = 476,
  Raypak_Inc = 477,
  Air_Monitor_Corporation_2 = 478,
  Regler_Och_Webbteknik_Sverige__ROWS_ = 479,
  Intelligent_Lighting_Controls_Inc_ = 480,
  Sanyo_Electric_Industry_Co___Ltd = 481,
  E-Mon_Energy_Monitoring_Products = 482,
  Digital_Control_Systems = 483,
  ATI_Airtest_Technologies__Inc_ = 484,
  SCS_SA = 485,
  HMS_Industrial_Networks_AB = 486,
  Shenzhen_Universal_Intellisys_Co_Ltd = 487,
  EK_Intellisys_Sdn_Bhd = 488,
  SysCom = 489,
  Firecom__Inc_ = 490,
  ESA_Elektroschaltanlagen_Grimma_GmbH = 491,
  Kumahira_Co_Ltd = 492,
  Hotraco = 493,
  SABO_Elektronik_GmbH = 494,
  Equip_Trans = 495,
  TCS_Basys_Controls = 496,
  FlowCon_International_A_S = 497,
  ThyssenKrupp_Elevator_Americas = 498,
  Abatement_Technologies = 499,
  Continental_Control_Systems__LLC = 500,
  WISAG_Automatisierungstechnik_GmbH___Co_KG = 501,
  EasyIO = 502,
  EAP-Electric_GmbH = 503,
  Hardmeier = 504,
  Mircom_Group_of_Companies = 505,
  Quest_Controls = 506,
  Mestek__Inc = 507,
  Pulse_Energy = 508,
  Tachikawa_Corporation = 509,
  University_of_Nebraska-Lincoln = 510,
  Redwood_Systems = 511,
  PASStec_Industrie-Elektronik_GmbH = 512,
  NgEK__Inc_ = 513,
  FAW_Electronics_Ltd = 514,
  Jireh_Energy_Tech_Co___Ltd_ = 515,
  Enlighted_Inc_ = 516,
  El-Piast_Sp__Z_o_o = 517,
  NetxAutomation_Software_GmbH = 518,
  Invertek_Drives = 519,
  Deutschmann_Automation_GmbH___Co__KG = 520,
  EMU_Electronic_AG = 521,
  Phaedrus_Limited = 522,
  Sigmatek_GmbH___Co_KG = 523,
  Marlin_Controls = 524,
  Circutor__SA = 525,
  UTC_Fire___Security = 526,
  DENT_Instruments__Inc_ = 527,
  FHP_Manufacturing_Company_-_Bosch_Group = 528,
  GE_Intelligent_Platforms = 529,
  Inner_Range_Pty_Ltd = 530,
  GLAS_Energy_Technology = 531,
  MSR-Electronic-GmbH = 532,
  Energy_Control_Systems__Inc_ = 533,
  EMT_Controls = 534,
  Daintree_Networks_Inc_ = 535,
  EURO_ICC_d_o_o = 536,
  TE_Connectivity_Energy = 537,
  GEZE_GmbH = 538,
  NEC_Corporation = 539,
  Ho_Cheung_International_Company_Limited = 540,
  Sharp_Manufacturing_Systems_Corporation = 541,
  DOT_CONTROLS_a_s_ = 542,
  BeaconMeds = 543,
  Midea_Commercial_Aircon = 544,
  WattMaster_Controls = 545,
  Kamstrup_A_S = 546,
  CA_Computer_Automation_GmbH = 547,
  Laars_Heating_Systems_Company = 548,
  Hitachi_Systems__Ltd_ = 549,
  Fushan_AKE_Electronic_Engineering_Co___Ltd_ = 550,
  Toshiba_International_Corporation = 551,
  Starman_Systems__LLC = 552,
  Samsung_Techwin_Co___Ltd_ = 553,
  ISAS-Integrated_Switchgear_and_Systems_P_L = 554,
  Obvius = 556,
  Marek_Guzik = 557,
  Vortek_Instruments__LLC = 558,
  Universal_Lighting_Technologies = 559,
  Myers_Power_Products__Inc_ = 560,
  Vector_Controls_GmbH = 561,
  Crestron_Electronics__Inc_ = 562,
  A_E_Controls_Limited = 563,
  Projektomontaza_A_D_ = 564,
  Freeaire_Refrigeration = 565,
  Aqua_Cooler_Pty_Limited = 566,
  Basic_Controls = 567,
  GE_Measurement_and_Control_Solutions_Advanced_Sensors = 568,
  EQUAL_Networks = 569,
  Millennial_Net = 570,
  APLI_Ltd = 571,
  Electro_Industries_GaugeTech = 572,
  SangMyung_University = 573,
  Coppertree_Analytics__Inc_ = 574,
  CoreNetiX_GmbH = 575,
  Acutherm = 576,
  Dr__Riedel_Automatisierungstechnik_GmbH = 577,
  Shina_System_Co___Ltd = 578,
  Iqapertus = 579,
  PSE_Technology = 580,
  BA_Systems = 581,
  BTICINO = 582,
  Monico__Inc_ = 583,
  iCue = 584,
  tekmar_Control_Systems_Ltd_ = 585,
  Control_Technology_Corporation = 586,
  GFAE_GmbH = 587,
  BeKa_Software_GmbH = 588,
  Isoil_Industria_SpA = 589,
  Home_Systems_Consulting_SpA = 590,
  Socomec = 591,
  Everex_Communications__Inc_ = 592,
  Ceiec_Electric_Technology = 593,
  Atrila_GmbH = 594,
  WingTechs = 595,
  Shenzhen_Mek_Intellisys_Pte_Ltd_ = 596,
  Nestfield_Co___Ltd_ = 597,
  Swissphone_Telecom_AG = 598,
  PNTECH_JSC = 599,
  Horner_APG__LLC = 600,
  PVI_Industries__LLC = 601,
  Ela-compil = 602,
  Pegasus_Automation_International_LLC = 603,
  Wight_Electronic_Services_Ltd_ = 604,
  Marcom = 605,
  Exhausto_A_S = 606,
  Dwyer_Instruments__Inc_ = 607,
  Link_GmbH = 608,
  Oppermann_Regelgerate_GmbH = 609,
  NuAire__Inc_ = 610,
  Nortec_Humidity__Inc_ = 611,
  Bigwood_Systems__Inc_ = 612,
  Enbala_Power_Networks = 613,
  Inter_Energy_Co___Ltd_ = 614,
  ETC = 615,
  COMELEC_S_A_R_L = 616,
  Pythia_Technologies = 617,
  TrendPoint_Systems__Inc_ = 618,
  AWEX = 619,
  Eurevia = 620,
  Kongsberg_E-lon_AS = 621,
  FlaktWoods = 622,
  E___E_Elektronik_GES_M_B_H_ = 623,
  ARC_Informatique = 624,
  SKIDATA_AG = 625,
  WSW_Solutions = 626,
  Trefon_Electronic_GmbH = 627,
  Dongseo_System = 628,
  Kanontec_Intelligence_Technology_Co___Ltd_ = 629,
  EVCO_S_p_A_ = 630,
  Accuenergy__CANADA__Inc_ = 631,
  SoftDEL = 632,
  Orion_Energy_Systems__Inc_ = 633,
  Roboticsware = 634,
  DOMIQ_Sp__z_o_o_ = 635,
  Solidyne = 636,
  Elecsys_Corporation = 637,
  Conditionaire_International_Pty__Limited = 638,
  Quebec__Inc_ = 639,
  Homerun_Holdings = 640,
  RFM__Inc_ = 641,
  Comptek = 642,
  Westco_Systems__Inc_ = 643,
  Advancis_Software___Services_GmbH = 644,
  Intergrid__LLC = 645,
  Markerr_Controls__Inc_ = 646,
  Toshiba_Elevator_and_Building_Systems_Corporation = 647,
  Spectrum_Controls__Inc_ = 648,
  Mkservice = 649,
  Fox_Thermal_Instruments = 650,
  SyxthSense_Ltd = 651,
  DUHA_System_S_R_O_ = 652,
  NIBE = 653,
  Melink_Corporation = 654,
  Fritz-Haber-Institut = 655,
  MTU_Onsite_Energy_GmbH__Gas_Power_Systems = 656,
  Omega_Engineering__Inc_ = 657,
  Avelon = 658,
  Ywire_Technologies__Inc_ = 659,
  M_R__Engineering_Co___Ltd_ = 660,
  Lochinvar__LLC = 661,
  Sontay_Limited = 662,
  GRUPA_Slawomir_Chelminski = 663,
  Arch_Meter_Corporation = 664,
  Senva__Inc_ = 665,
  FM-Tec = 667,
  Systems_Specialists__Inc_ = 668,
  SenseAir = 669,
  AB_IndustrieTechnik_Srl = 670,
  Cortland_Research__LLC = 671,
  MediaView = 672,
  VDA_Elettronica = 673,
  CSS__Inc_ = 674,
  Tek-Air_Systems__Inc_ = 675,
  ICDT = 676,
  The_Armstrong_Monitoring_Corporation = 677,
  DIXELL_S_r_l = 678,
  Lead_System__Inc_ = 679,
  ISM_EuroCenter_S_A_ = 680,
  TDIS = 681,
  Trade_FIDES = 682,
  Knrr_GmbH__Emerson_Network_Power_ = 683,
  Resource_Data_Management = 684,
  Abies_Technology__Inc_ = 685,
  Amalva = 686,
  MIRAE_Electrical_Mfg__Co___Ltd_ = 687,
  HunterDouglas_Architectural_Projects_Scandinavia_ApS = 688,
  RUNPAQ_Group_Co___Ltd = 689,
  Unicard_SA = 690,
  IE_Technologies = 691,
  Ruskin_Manufacturing = 692,
  Calon_Associates_Limited = 693,
  Contec_Co___Ltd_ = 694,
  iT_GmbH = 695,
  Autani_Corporation = 696,
  Christian_Fortin = 697,
  HDL = 698,
  IPID_Sp__Z_O_O_Limited = 699,
  Fuji_Electric_Co___Ltd = 700,
  View__Inc_ = 701,
  Samsung_S1_Corporation = 702,
  New_Lift = 703,
  VRT_Systems = 704,
  Motion_Control_Engineering__Inc_ = 705,
  Weiss_Klimatechnik_GmbH = 706,
  Elkon = 707,
  Eliwell_Controls_S_r_l_ = 708,
  Japan_Computer_Technos_Corp = 709,
  Rational_Network_ehf = 710,
  Magnum_Energy_Solutions__LLC = 711,
  MelRok = 712,
  VAE_Group = 713,
  LGCNS = 714,
  Berghof_Automationstechnik_GmbH = 715,
  Quark_Communications__Inc_ = 716,
  Sontex = 717,
  mivune_AG = 718,
  Panduit = 719,
  Smart_Controls__LLC = 720,
  Compu-Aire__Inc_ = 721,
  Sierra = 722,
  ProtoSense_Technologies = 723,
  Eltrac_Technologies_Pvt_Ltd = 724,
  Bektas_Invisible_Controls_GmbH = 725,
  Entelec = 726
};

export type BACnetPropertyIdentifier = enum {
  absentee-limit = 244,
  accepted-modes = 175,
  access-alarm-events = 245,
  access-doors = 246,
  access-event = 247,
  access-event-authentication-factor = 248,
  access-event-credential = 249,
  access-event-tag = 322,
  access-event-time = 250,
  access-transaction-events = 251,
  accompaniment = 252,
  accompaniment-time = 253,
  ack-required = 1,
  acked-transitions = 0,
  action = 2,
  action-text = 3,
  activation-time = 254,
  active-authentication-policy = 255,
  active-cov-subscriptions = 152,
  active-text = 4,
  active-vt-sessions = 5,
  actual-shed-level = 212,
  adjust-value = 176,
  alarm-value = 6,
  alarm-values = 7,
  align-intervals = 193,
  all = 8,
  all-writes-successful = 9,
  allow-group-delay-inhibit = 365,
  apdu-segment-timeout = 10,
  apdu-timeout = 11,
  application-software-version = 12,
  archive = 13,
  assigned-access-rights = 256,
  attempted-samples = 124,
  authentication-factors = 257,
  authentication-policy-list = 258,
  authentication-policy-names = 259,
  authentication-status = 260,
  authorization-exemptions = 364,
  authorization-mode = 261,
  auto-slave-discovery = 169,
  average-value = 125,
  backup-and-restore-state = 338,
  backup-failure-timeout = 153,
  backup-preparation-time = 339,
  base-device-security-policy = 327,
  belongs-to = 262,
  bias = 14,
  bit-mask = 342,
  bit-text = 343,
  blink-warn-enable = 373,
  buffer-size = 126,
  change-of-state-count = 15,
  change-of-state-time = 16,
  channel-number = 366,
  client-cov-increment = 127,
  configuration-files = 154,
  control-groups = 367,
  controlled-variable-reference = 19,
  controlled-variable-units = 20,
  controlled-variable-value = 21,
  count = 177,
  count-before-change = 178,
  count-change-time = 179,
  cov-increment = 22,
  cov-period = 180,
  cov-resubscription-interval = 128,
  covu-period = 349,
  covu-recipients = 350,
  credential-disable = 263,
  credential-status = 264,
  credentials = 265,
  credentials-in-zone = 266,
  database-revision = 155,
  date-list = 23,
  daylight-savings-status = 24,
  days-remaining = 267,
  deadband = 25,
  default-fade-time = 374,
  default-ramp-rate = 375,
  default-step-increment = 376,
  derivative-constant = 26,
  derivative-constant-units = 27,
  description = 28,
  description-of-halt = 29,
  device-address-binding = 30,
  device-type = 31,
  direct-reading = 156,
  distribution-key-revision = 328,
  do-not-hide = 329,
  door-alarm-state = 226,
  door-extended-pulse-time = 227,
  door-members = 228,
  door-open-too-long-time = 229,
  door-pulse-time = 230,
  door-status = 231,
  door-unlock-delay-time = 232,
  duty-window = 213,
  effective-period = 32,
  egress-time = 377,
  egress-active = 386,
  elapsed-active-time = 33,
  entry-points = 268,
  enable = 133,
  error-limit = 34,
  event-algorithm-inhibit = 354,
  event-algorithm-inhibit-ref = 355,
  event-detection-enable = 353,
  event-enable = 35,
  event-message-texts = 351,
  event-message-texts-config = 352,
  event-state = 36,
  event-time-stamps = 130,
  event-type = 37,
  event-parameters = 83,
  exception-schedule = 38,
  execution-delay = 368,
  exit-points = 269,
  expected-shed-level = 214,
  expiry-time = 270,
  extended-time-enable = 271,
  failed-attempt-events = 272,
  failed-attempts = 273,
  failed-attempts-time = 274,
  fault-parameters = 358,
  fault-type = 359,
  fault-values = 39,
  feedback-value = 40,
  file-access-method = 41,
  file-size = 42,
  file-type = 43,
  firmware-revision = 44,
  full-duty-baseline = 215,
  global-identifier = 323,
  group-members = 345,
  group-member-names = 346,
  high-limit = 45,
  inactive-text = 46,
  in-process = 47,
  in-progress = 378,
  input-reference = 181,
  instance-of = 48,
  instantaneous-power = 379,
  integral-constant = 49,
  integral-constant-units = 50,
  interval-offset = 195,
  is-utc = 344,
  key-sets = 330,
  last-access-event = 275,
  last-access-point = 276,
  last-credential-added = 277,
  last-credential-added-time = 278,
  last-credential-removed = 279,
  last-credential-removed-time = 280,
  last-key-server = 331,
  last-notify-record = 173,
  last-priority = 369,
  last-restart-reason = 196,
  last-restore-time = 157,
  last-use-time = 281,
  life-safety-alarm-values = 166,
  lighting-command = 380,
  lighting-command-default-priority = 381,
  limit-enable = 52,
  limit-monitoring-interval = 182,
  list-of-group-members = 53,
  list-of-object-property-references = 54,
  local-date = 56,
  local-forwarding-only = 360,
  local-time = 57,
  location = 58,
  lock-status = 233,
  lockout = 282,
  lockout-relinquish-time = 283,
  log-buffer = 131,
  log-device-object-property = 132,
  log-interval = 134,
  logging-object = 183,
  logging-record = 184,
  logging-type = 197,
  low-limit = 59,
  maintenance-required = 158,
  manipulated-variable-reference = 60,
  manual-slave-address-binding = 170,
  masked-alarm-values = 234,
  maximum-output = 61,
  maximum-value = 135,
  maximum-value-timestamp = 149,
  max-actual-value = 382,
  max-apdu-length-accepted = 62,
  max-failed-attempts = 285,
  max-info-frames = 63,
  max-master = 64,
  max-pres-value = 65,
  max-segments-accepted = 167,
  member-of = 159,
  member-status-flags = 347,
  members = 286,
  minimum-off-time = 66,
  minimum-on-time = 67,
  minimum-output = 68,
  minimum-value = 136,
  minimum-value-timestamp = 150,
  min-actual-value = 383,
  min-pres-value = 69,
  mode = 160,
  model-name = 70,
  modification-date = 71,
  muster-point = 287,
  negative-access-rules = 288,
  network-access-security-policies = 332,
  node-subtype = 207,
  node-type = 208,
  notification-class = 17,
  notification-threshold = 137,
  notify-type = 72,
  number-of-apdu-retries = 73,
  number-of-authentication-policies = 289,
  number-of-states = 74,
  object-identifier = 75,
  object-list = 76,
  object-name = 77,
  object-property-reference = 78,
  object-type = 79,
  occupancy-count = 290,
  occupancy-count-adjust = 291,
  occupancy-count-enable = 292,
  occupancy-lower-limit = 294,
  occupancy-lower-limit-enforced = 295,
  occupancy-state = 296,
  occupancy-upper-limit = 297,
  occupancy-upper-limit-enforced = 298,
  operation-expected = 161,
  optional_ = 80,
  out-of-service = 81,
  output-units = 82,
  packet-reorder-time = 333,
  passback-mode = 300,
  passback-timeout = 301,
  polarity = 84,
  port-filter = 363,
  positive-access-rules = 302,
  power = 384,
  prescale = 185,
  present-value = 85,
  bacnet-priority = 86,
  priority-array = 87,
  priority-for-writing = 88,
  process-identifier = 89,
  process-identifier-filter = 361,
  profile-name = 168,
  program-change = 90,
  program-location = 91,
  program-state = 92,
  property-list = 371,
  proportional-constant = 93,
  proportional-constant-units = 94,
  protocol-object-types-supported = 96,
  protocol-revision = 139,
  protocol-services-supported = 97,
  protocol-version = 98,
  pulse-rate = 186,
  read-only = 99,
  reason-for-disable = 303,
  reason-for-halt = 100,
  recipient-list = 102,
  records-since-notification = 140,
  record-count = 141,
  reliability = 103,
  reliability-evaluation-inhibit = 357,
  relinquish-default = 104,
  requested-shed-level = 218,
  requested-update-interval = 348,
  required = 105,
  resolution = 106,
  restart-notification-recipients = 202,
  restore-completion-time = 340,
  restore-preparation-time = 341,
  scale = 187,
  scale-factor = 188,
  schedule-default = 174,
  secured-status = 235,
  security-pdu-timeout = 334,
  security-time-window = 335,
  segmentation-supported = 107,
  serial-number = 372,
  setpoint = 108,
  setpoint-reference = 109,
  setting = 162,
  shed-duration = 219,
  shed-level-descriptions = 220,
  shed-levels = 221,
  silenced = 163,
  slave-address-binding = 171,
  slave-proxy-enable = 172,
  start-time = 142,
  state-description = 222,
  state-text = 110,
  status-flags = 111,
  stop-time = 143,
  stop-when-full = 144,
  structured-object-list = 209,
  subordinate-annotations = 210,
  subordinate-list = 211,
  subscribed-recipients = 362,
  supported-formats = 304,
  supported-format-classes = 305,
  supported-security-algorithms = 336,
  system-status = 112,
  threat-authority = 306,
  threat-level = 307,
  time-delay = 113,
  time-delay-normal = 356,
  time-of-active-time-reset = 114,
  time-of-device-restart = 203,
  time-of-state-count-reset = 115,
  time-synchronization-interval = 204,
  time-synchronization-recipients = 116,
  total-record-count = 145,
  trace-flag = 308,
  tracking-value = 164,
  transaction-notification-class = 309,
  transition = 385,
  trigger = 205,
  units = 117,
  update-interval = 118,
  update-key-set-timeout = 337,
  update-time = 189,
  user-external-identifier = 310,
  user-information-reference = 311,
  user-name = 317,
  user-type = 318,
  uses-remaining = 319,
  utc-offset = 119,
  utc-time-synchronization-recipients = 206,
  valid-samples = 146,
  value-before-change = 190,
  value-set = 191,
  value-change-time = 192,
  variance-value = 151,
  vendor-identifier = 120,
  vendor-name = 121,
  verification-time = 326,
  vt-classes-supported = 122,
  weekly-schedule = 123,
  window-interval = 147,
  window-samples = 148,
  write-status = 370,
  zone-from = 320,
  zone-members = 165,
  zone-to = 321,
# The special property identifiers all, optional, and required are reserved for use in the
# ReadPropertyMultiple service or services not defined in this standard.
#
# Enumerated values 0-511 are reserved for definition by ASHRAE. Enumerated values 512-4194303 may be used by
# others subject to the procedures and constraints described in Clause 23.
#
# Old and removed:
  issue-confirmed-notifications = 51,
  protocol-conformance-class = 95,
  recipient = 101,
  current-notify-time = 129,
  previous-notify-time = 138,
  master-exemption = 284,
  occupancy-exemption = 293,
  passback-exemption = 299
};

type BACnetEventType = enum {
  change-of-bitstring = 0,
  change-of-state = 1,
  change-of-value = 2,
  command-failure = 3,
  floating-limit = 4,
  out-of-range = 5,
  # complex-event-type = 6,
  # context tag 7 is deprecated
  change-of-life-safety = 8,
  extended = 9,
  buffer-ready = 10,
  unsigned-range = 11,
  # enumeration value 12 is reserved for future addenda
  access-event = 13,
  double-out-of-range = 14,
  signed-out-of-range = 15,
  unsigned-out-of-range = 16,
  change-of-characterstring = 17,
  change-of-status-flags = 18,
  change-of-reliability = 19,
  none = 20
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23. It is expected that these enumerated values will correspond to the use of the
## complex-event-type CHOICE [6] of the BACnetNotificationParameters production.
};

type BACnetNotifyType = enum {
  alarm = 0,
  event = 1,
  ack-notification = 2
};

type BACnetEventState = enum {
  normal = 0,
  fault = 1,
  offnormal = 2,
  high-limit = 3,
  low-limit = 4,
  life-safety-alarm = 5
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23. The last enumeration used in this version is 5.
};

type BACnetLifeSafetyMode = enum {
  off = 0,
  bacnet-on = 1, # original: on
  test = 2,
  manned = 3,
  unmanned = 4,
  armed = 5,
  disarmed = 6,
  prearmed = 7,
  slow = 8,
  fast = 9,
  disconnected = 10,
  enabled = 11,
  disabled = 12,
  automatic-release-disabled = 13,
  default = 14
## Enumerated values 0-255 are reserved for definition by ASHRAE. Enumerated values
## 256-65535 may be used by others subject to procedures and constraints described in Clause 23.
};

type BACnetLifeSafetyOperation = enum {
  none = 0,
  silence = 1,
  silence-audible = 2,
  silence-visual = 3,
  reset = 4,
  reset-alarm = 5,
  reset-fault = 6,
  unsilence = 7,
  unsilence-audible = 8,
  unsilence-visual = 9
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to procedures and constraints described in
## Clause 23.
};

type BACnetLifeSafetyState = enum {
  quiet = 0,
  pre-alarm = 1,
  alarm = 2,
  fault = 3,
  fault-pre-alarm = 4,
  fault-alarm = 5,
  not-ready = 6,
  active = 7,
  tamper = 8,
  test-alarm = 9,
  test-active = 10,
  test-fault = 11,
  test-fault-alarm = 12,
  holdup = 13,
  duress = 14,
  tamper-alarm = 15,
  abnormal = 16,
  emergency-power = 17,
  delayed = 18,
  blocked = 19,
  local-alarm = 20,
  general-alarm = 21,
  supervisory = 22,
  test-supervisory = 23
## Enumerated values 0-255 are reserved for definition by ASHRAE. Enumerated values
## 256-65535 may be used by others subject to procedures and constraints described in Clause 23.
};

type BACnetAccessEvent = enum {
  none = 0,
  granted = 1,
  muster = 2,
  passback-detected = 3,
  duress = 4,
  trace = 5,
  lockout-max-attempts = 6,
  lockout-other = 7,
  lockout-relinquished = 8,
  locked-by-higher-priority = 9,
  out-of-service = 10,
  out-of-service-relinquished = 11,
  accompaniment-by = 12,
  authentication-factor-read = 13,
  authorization-delayed = 14,
  verification-required = 15,
  no-entry-after-grant = 16,
## Enumerated values 128-511 are used for events which indicate that access has been denied.
  denied-deny-all = 128,
  denied-unknown-credential = 129,
  denied-authentication-unavailable = 130,
  denied-authentication-factor-timeout = 131,
  denied-incorrect-authentication-factor = 132,
  denied-zone-no-access-rights = 133,
  denied-point-no-access-rights = 134,
  denied-no-access-rights = 135,
  denied-out-of-time-range = 136,
  denied-threat-level = 137,
  denied-passback = 138,
  denied-unexpected-location-usage = 139,
  denied-max-attempts = 140,
  denied-lower-occupancy-limit = 141,
  denied-upper-occupancy-limit = 142,
  denied-authentication-factor-lost = 143,
  denied-authentication-factor-stolen = 144,
  denied-authentication-factor-damaged = 145,
  denied-authentication-factor-destroyed = 146,
  denied-authentication-factor-disabled = 147,
  denied-authentication-factor-error = 148,
  denied-credential-unassigned = 149,
  denied-credential-not-provisioned = 150,
  denied-credential-not-yet-active = 151,
  denied-credential-expired = 152,
  denied-credential-manual-disable = 153,
  denied-credential-lockout = 154,
  denied-credential-max-days = 155,
  denied-credential-max-uses = 156,
  denied-credential-inactivity = 157,
  denied-credential-disabled = 158,
  denied-no-accompaniment = 159,
  denied-incorrect-accompaniment = 160,
  denied-lockout = 161,
  denied-verification-failed = 162,
  denied-verification-timeout = 163,
  denied-other = 164
## Enumerated values 0-511 are reserved for definition by ASHRAE. Enumerated values
## 512-65535 may be used by others subject to the procedures and constraints described
## in Clause 23.
};

type BACnetAuthenticationFactorType = enum {
  undefined = 0,
  error = 1,
  custom = 2,
  simple-number16 = 3,
  simple-number32 = 4,
  simple-number56 = 5,
  simple-alpha-numeric = 6,
  aba-track2 = 7,
  wiegand26 = 8,
  wiegand37 = 9,
  wiegand37-facility = 10,
  facility16-card32 = 11,
  facility32-card32 = 12,
  fasc-n = 13,
  fasc-n-bcd = 14,
  fasc-n-large = 15,
  fasc-n-large-bcd = 16,
  gsa75 = 17,
  chuid = 18,
  chuid-full = 19,
  guid = 20,
  cbeff-A = 21,
  cbeff-B = 22,
  cbeff-C = 23,
  user-password = 24
};

type BACnetReliability = enum {
  no-fault-detected = 0,
  no-sensor = 1,
  over-range = 2,
  under-range = 3,
  open-loop = 4,
  shorted-loop = 5,
  no-output = 6,
  unreliable-other = 7,
  process-error = 8,
  multi-state-fault = 9,
  configuration-error = 10,
## enumeration value 11 is reserved for a future addendum
  communication-failure = 12,
  member-fault = 13,
  monitored-object-fault = 14,
  tripped = 15
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23.
};

export type BVLC_function = enum {
  # message distribution
  Original-Unicast-NPDU = 0x0A,
  Original-Broadcast-NPDU = 0x0B,
  Distribute-Broadcast-To-Network = 0x09,
  Forwarded-NPDU = 0x04,
  # bbmd broadcast distribution & foreign device table management
  Secure-BVLL = 0x0C,
  BVLC-Result = 0x00,
  Write-BDT = 0x01,
  Read-BDT = 0x02,
  Read-BDT-ACK= 0x03,
  Register-FD = 0x05,
  Read-FDT = 0x06,
  Read-FDT-ACK = 0x07,
  Delete-FDT-Entry = 0x08
};

export type Message = unit {
  %mimetype = "protocol/bacnet";
  %mimetype = "port-udp/47808";

  # outer protocol exposed to UDP is BVLC
  tpe: uint8(0x81);
  func: uint8 &convert=BVLC_function($$);
  len: uint16;

  switch ( self.func ) {
   BVLC_function::Original-Unicast-NPDU,
   BVLC_function::Original-Broadcast-NPDU,
   BVLC_function::Distribute-Broadcast-To-Network -> npdu: NPDU(self.len - 4);
   BVLC_function::Forwarded-NPDU -> {
     originator: addr &ipv4;
     originator_port: uint16;
     npdu: NPDU(self.len - 10); # 4 bytes header + IP Address + port
   }
   BVLC_function::BVLC-Result,
   BVLC_function::Write-BDT,
   BVLC_function::Read-BDT,
   BVLC_function::Read-BDT-ACK,
   BVLC_function::Register-FD,
   BVLC_function::Read-FDT,
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> bbmd: BBMD( self.func, self.len - 4 );
   # BVLC_function::Secure-BVLL Not yet supported, probably not used
  };
};

export type BVLC_result = enum {
  Success = 0x0000,
  Write-BDT-NAK = 0x0010,
  Read-BDT-NAK = 0x0020,
  Register-FD-NAK = 0x0030,
  Read-FDT-NAK = 0x0040,
  Delete-FDT-NAK = 0x0050,
  Distribute-Broadcast-To-Network-NAK = 0x0060
};

# Broadcast Distribution Table. Due to the fact that BACnet cannot
# trust the underlying IP network do to broadcasting right, it does
# it itself.
#
# Each BACnet/IP Broadcast Management Device (BBMD) has a Broadcast
# Distribution table which contains the network addresses to which
# broadcasts are forwarded.
type BDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  mask: uint32;
};

# convert a BDT entry into a Bro tuple
tuple<addr, uint64, uint64> bro_bdt_entry(entry: BDT_entry) {
  return ( entry.address, cast<uint64>(entry.address_port), cast<uint64>(entry.mask) );
}

# Foreign Device Table, also held by a BBMD. Foreign devices are
# devices that belong to a BACnet network, but reside on a different
# IP subnet as the other devices forming the subnet.
type FDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  ttl: uint16;
  time_remaining: uint16;
};

# convert a FDT entry into a Bro tuple
tuple<addr, uint64, uint64, uint64> bro_fdt_entry(entry: FDT_entry) {
  return ( entry.address, cast<uint64>(entry.address_port), cast<uint64>(entry.ttl), cast<uint64>(entry.time_remaining) );
}

type BBMD = unit (func: BVLC_function, len: uint16) {
   # var bdts_brolist: list< tuple<addr, uint64, uint64> >;

  switch ( func ) {
   BVLC_function::BVLC-Result -> bvlc_result: uint16 &convert=BVLC_result($$);
   BVLC_function::Read-BDT-ACK,
   # FIXME: for some reason &length does not seem to work here. Perhaps it has problems with addr &ipv4?
   BVLC_function::Write-BDT -> bdts: list<BDT_entry> &count=len/10;
   BVLC_function::Read-FDT,
   BVLC_function::Read-BDT -> : void;
   BVLC_function::Register-FD -> ttl: uint16;
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> fdts: list<FDT_entry> &count=len/10;
  };
};

export type NPDU_type = enum {
  Who-Is-Router-To-Network = 0x00,
  I-Am-Router-To-Network = 0x01,
  I-Could-Be-Router-To-Network = 0x02,
  Reject-Message-To-Network = 0x03,
  Router-Busy-To-Network = 0x04,
  Router-Available-To-Network = 0x05,
  Initialize-Routing-Table = 0x06,
  Initialize-Routing-Table-Ack = 0x07,
  Establish-Connection-To-Network = 0x08,
  Disconnect-Connection-To-Network = 0x09,
  Challenge-Request = 0x0A,
  Security-Payload = 0x0B,
  Security-Response = 0x0C,
  Request-Key-Update = 0x0D,
  Update-Key-Set = 0x0E,
  Update-Distribution-Key = 0x0F,
  Request-Master-Key = 0x10,
  Set-Master-Key = 0x11,
  What-Is-Network-Number = 0x12,
  Network-Numer-Is = 0x13
};

export type NPDU_priority = enum {
  Normal = 0,
  Urgent = 1,
  Critical = 2,
  Life-Safety = 3
};

# convert data present in all NPDUs into a NPDU_info record
tuple<NPDU_priority, uint64, bytes, uint64, bytes, uint64, NPDU_type> bro_npdu_info(npdu: NPDU) {
#  return ( npdu.priority, cast<uint64>(npdu.dnet), npdu.dadr, cast<uint64>(npdu.snet), npdu.sadr, cast<uint64>(npdu.hop_count), npdu.message_type );
# Fixme: since nearly all of these are optionals, we cannot return them
# at the moment..

  return (npdu.bacnet-priority, 0, b"", 0, b"", 0, npdu.message_type);
}

type NPDU = unit(len: uint16) {
  var bacnet-priority: NPDU_priority;

  version: uint8; # should be 0x1, but trace also has 10?
  control : bitfield(8) {
    bacnet-priority: 0..1;
    der: 2;
    source: 3;
    reserved1: 4;
    destination: 5;
    reserved2: 6;
    nlmessage: 7;
  } {
    self.bacnet-priority = NPDU_priority(self.control.bacnet-priority);
  }

  dnet: uint16 if ( self.control.destination == 1 );
  dlen: uint8 if ( self.control.destination == 1 );
  dadr: bytes &length=self.dlen if ( self.control.destination == 1 );
  snet: uint16 if ( self.control.source == 1 );
  slen: uint8 if ( self.control.source == 1 );
  sadr: bytes &length=self.slen if ( self.control.source == 1 );
  hop_count: uint8 if ( self.control.destination == 1);
  message_type: uint8 &convert=NPDU_type($$) if ( self.control.nlmessage == 1 );

  npdu_message: NPDU_message( (len - cast<uint16>(self.offset())), self.message_type) if ( self.control.nlmessage == 1 );

  # if nlmessage == 0, APDU follows
  apdu: APDU( len - cast<uint16>(self.offset()) ) if ( self.control.nlmessage == 0 );
};

export type NPDU_Reject_reason = enum {
  Other = 0,
  No_route = 1,
  Router_busy = 2,
  Unknown_message_type = 3,
  Message_too_long = 4,
  Security_error = 5,
  Addressing_error = 6
};

type NPDU_message = unit(len: uint16, t: NPDU_type) {
  # len only is remaining length
  switch ( t ) {
    NPDU_type::Who-Is-Router-To-Network,
    NPDU_type::Disconnect-Connection-To-Network -> dnets: list<uint16> &length=len;
    NPDU_type::I-Am-Router-To-Network,
    NPDU_type::Router-Busy-To-Network,
    NPDU_type::Router-Available-To-Network -> dnets: list<uint16> &length=len;
    NPDU_type::I-Could-Be-Router-To-Network -> {
      dnets: list<uint16> &count=1;
      performance_index: uint8;
    }
    NPDU_type::Reject-Message-To-Network -> {
      reason: uint8 &convert=NPDU_Reject_reason($$);
      dnets: list<uint16> &count=1;
    }
    NPDU_type::Establish-Connection-To-Network -> {
      dnets: list<uint16> &count=1;
      termination_time: uint8;
    }
    NPDU_type::What-Is-Network-Number -> : void; # empty packet
    NPDU_type::Network-Numer-Is -> {
      network_number: uint16;
      learned: uint8;
    }
    NPDU_type::Initialize-Routing-Table,
    NPDU_type::Initialize-Routing-Table-Ack -> {
      number_ports: uint8 if ( len > 0 );
      routing_entries: list<NPDU_routing_entry> &count=self.number_ports if ( len > 0 );
    }
  };
};

# convert a NPDU routing entry into a Bro tuple
tuple<uint64, uint64, bytes> bro_npdu_routing_entry(entry: NPDU_routing_entry) {
  return ( cast<uint64>(entry.dnet), cast<uint64>(entry.portId), entry.portInfo );
}

type NPDU_routing_entry = unit {
  dnet: uint16;
  portId: uint8;
  portInfo_len: uint8;
  portInfo: bytes &length=self.portInfo_len;
};

type PDU_type = enum {
  ConfirmedRequest = 0,
  Unconfirmed-Request = 1,
  SimpleAck = 2,
  ComplexAck = 3,
  SegmentAck = 4,
  Error = 5,
  Reject = 5,
  Abort = 7
};

type APDU = unit(len: uint16) {
  # ok, the first 4 bits contain the actual message type - but we need them later.
  head: bytes &length = 1;
  var tpe: PDU_type;
  tpe_raw: uint8 &parse(self.head) {
    self.tpe_raw = (self.tpe_raw & 0xF0) >> 4;
    self.tpe = PDU_type(self.tpe_raw);
  }

  switch ( self.tpe ) {
    PDU_type::ConfirmedRequest -> confirmed_request: PDU_confirmedRequest(self.head, len);
    PDU_type::Unconfirmed-Request -> unconfirmed_request: PDU_unconfirmedRequest(len);
    PDU_type::SimpleAck -> simple_ack: PDU_simpleACK;
    PDU_type::ComplexAck -> complex_ack: BACnet_ComplexACK_PDU(self.head, len);
    PDU_type::SegmentAck -> segment_ack: BACnet_SegmentACK_PDU(self.head);
    PDU_type::Error -> error: PDU_error;
    PDU_type::Reject -> reject: PDU_reject;
    PDU_type::Abort -> abort: PDU_abort(self.head);
  };
};

export type BACnetConfirmedServiceChoice = enum {
  # Alarm and Event Services
  acknowledgeAlarm = 0,
  confirmedCOVNotification = 1,
  confirmedEventNotification = 2,
  getAlarmSummary = 3,
  getEnrollmentSummary = 4,
  getEventInformation = 29,
  subscribeCOV = 5,
  subscribeCOVProperty = 28,
  lifeSafetyOperation = 27,
  # File Access Services
  atomicReadFile = 6,
  atomicWriteFile = 7,
  # Object Access Services
  addListElement = 8,
  removeListElement = 9,
  createObject = 10,
  deleteObject = 11,
  readProperty = 12,
  readPropertyMultiple = 14,
  readRange = 26,
  writeProperty = 15,
  writePropertyMultiple = 16,
  # Remote Device Management Services
  deviceCommunicationControl = 17,
  confirmedPrivateTransfer = 18,
  confirmedTextMessage = 19,
  reinitializeDevice = 20,
  # Virtual Terminal Services
  vtOpen = 21,
  vtClose = 22,
  vtData = 23
};

type BACnet_SegmentACK_PDU = unit(head: bytes) {
   head : bitfield(8) {
    srv: 0; # sent by server? 0 = by client
    nak: 1; # 0 = normal acknowledgment. 1 = negative acknowledgment, segment out of order
    tpe: 4..7;
  } &parse(head);

  invokeID: uint8;
  sequence_number: uint8;
  actual_window_size: uint8;
};

global confirmedReq_bytes: map<uint8, bytes>; # store the current bytes
global confirmedReq_status: map<uint8, uint8>; # store the current invokeId to sequence number mapping

type PDU_confirmedRequest = unit(head: bytes, len: uint16) {
  var len: uint16 = 4;
  var segmentation_status: bool = False;

  head1 : bitfield(8) {
    segmented-response-accepted: 1;
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head) {
    if ( self.head1.segmented-message == 1 ) {
      self.len = self.len + 2;
    }
  }
  head2: bitfield(8) {
    max-APDU-length-accepted: 0..3;
    max-segments-accepted: 4..6;
  };

  invokeID: uint8;
  sequence_number: uint8 if ( self.head1.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head1.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);

  # Segmentation is by invokeID with increasing sequence numbers (first is 0).
  # If more-follows == 0, we can just re-assemble the packet and parse it in a second
  # step.
  content_bytes: bytes &length=( len - self.len ) if ( self.head1.segmented-message == 1 ) {

    # first segment - initialize data structures
    if ( ( self.head1.segmented-message == 1 ) && ( self.sequence_number == 0)  ) {
      confirmedReq_status[self.invokeID] = 0;
      confirmedReq_bytes[self.invokeID] = self.content_bytes;
      #print "First segment, invokeID", self.invokeID;
    } else if ( ( self.head1.segmented-message == 1 ) && ( self.sequence_number > 0 ) ) {
    # segment other than the first.
    # look if we already know the invokeID and the right sequence number is following. Otherwise - abort or
    # ignore
      if ( self.invokeID in confirmedReq_status ) {
        if ( confirmedReq_status[self.invokeID] >= self.sequence_number ) {
          # we already have this one, skip...
          #print "Skipped fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", confirmedReq_status[self.invokeID];
        } else if ( confirmedReq_status[self.invokeID] == ( self.sequence_number - 1 ) ) {
          # add fragment
          #print "Added fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", confirmedReq_status[self.invokeID];
          #if ( self.head1.more-follows == 0 ) {
          #  print "Last fragment";
          #}
          confirmedReq_status[self.invokeID] = self.sequence_number;
          confirmedReq_bytes[self.invokeID] = confirmedReq_bytes[self.invokeID] + self.content_bytes;
          self.content_bytes = confirmedReq_bytes[self.invokeID];
          self.segmentation_status = True;
        } else {
          # we missed a fragment. Kill it...
          # Fixme: and output an error or whatever
          #print "Missing fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", confirmedReq_status[self.invokeID];
          delete confirmedReq_bytes[self.invokeID];
          delete confirmedReq_status[self.invokeID];
        }
      } else {
        #print "Unknown fragment, invokeID", self.invokeID, "sequence number", self.sequence_number;
      }
    }
  }

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::confirmedEventNotification -> confirmedEventNotification: ConfirmedEventNotification_Request( len - self.len );
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_Request( len - self.len, self.invokeID );
    BACnetConfirmedServiceChoice::writeProperty -> writeProperty: WriteProperty_Request( len - self.len );
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_Request( self.invokeID );
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_Request;
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_Request( len - self.len );
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_Request( len - self.len );
    * -> : void; # { print "unhandled confirmedrequest", self.confirmed_service_choice; }
  } if ( self.head1.more-follows == 0 && self.head1.segmented-message == 0 );

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::confirmedEventNotification -> confirmedEventNotification: ConfirmedEventNotification_Request( len - self.len );
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_Request( len - self.len, self.invokeID );
    BACnetConfirmedServiceChoice::writeProperty -> writeProperty: WriteProperty_Request( len - self.len );
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_Request( self.invokeID );
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_Request;
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_Request( len - self.len );
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_Request( len - self.len );
    * -> : void; # { print "unhandled confirmedrequest", self.confirmed_service_choice; }
  } if ( ( self.head1.more-follows == 0 ) && ( self.head1.segmented-message == 1 ) && ( self.segmentation_status ) ); # only parse message if we are in last chunk and have all data

    : void {
      if ( ( self.head1.more-follows == 0 ) && ( self.head1.segmented-message == 1 ) && ( self.segmentation_status ) ) {
        #print "Reassembled:", self.invokeID;
        delete confirmedReq_bytes[self.invokeID];
        delete confirmedReq_status[self.invokeID];
      }
    }
};

type ReadRange_Request = unit(len: uint16) {
  # context specific tags 0-6, last few optional choice
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  var propertyIdentifier: BACnetPropertyIdentifier;
  propertyIdentifier_raw: BACnetContextMessage(BACnetType::Enumerated, 1, self.objectIdentifier.tag) {
    self.propertyIdentifier = BACnetPropertyIdentifier(self.propertyIdentifier_raw.unsigned);
  }
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_raw.tag);
  # Range
  range: BACnetTag if ( len > self.offset() );
  ## byPosition - 3
  ## 4 and 5 are deprecated
  ## bySequenceNumber - 6
  ## byTime - 7

  # types vary by range choice.
  reference: BACnetMessage if ( len > self.offset() );
  count: BACnetMessage if ( len > self.offset() ); # integer16 optional
};

type ConfirmedPrivateTransfer_Request = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  var vendorID: BACnetVendorIDs;
  vendorID_raw: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag) {
    self.vendorID = BACnetVendorIDs(self.vendorID_raw.unsigned);
    #print "vendorID ConfirmedPrivateTransfer_Request", self.vendorID;
  }
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID_raw.tag);
  serviceParameters: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type ConfirmedEventNotification_Request = unit(len: uint16) {
  # context-specific tags 0 - 12
  first_tag: BACnetTag;
  processIdentifier: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  initiatingDeviceIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 1, self.processIdentifier.tag);
  eventObjectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.initiatingDeviceIdentifier.tag);
  timeStamp_tag: BACnetTag; # wrapped timestamp
  timeStamp: BACnetTimeStamp;
  : BACnetTag if ( self.timeStamp_tag.lvt == 6 ); # end tag, has to have tag == 3
  notificationClass: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.timeStamp_tag);
  bacnet-priority: BACnetContextMessage(BACnetType::UnsignedInteger, 5, self.notificationClass.tag);
  var eventType: BACnetEventType;
  eventType_raw: BACnetContextMessage(BACnetType::Enumerated, 6, self.bacnet-priority.tag) { # BACnetEventType
    self.eventType = BACnetEventType(self.eventType_raw.unsigned);
  }
  messageText: BACnetContextMessage(BACnetType::CharacterString, 7, self.eventType_raw.tag); # optional
  var notifyType: BACnetNotifyType;
  notifyType_raw: BACnetContextMessage(BACnetType::Enumerated, 8, self.messageText.tag) { # BACnetNotifyType,
    self.notifyType = BACnetNotifyType(self.notifyType_raw.unsigned);
  }
  ackRequired: BACnetContextMessage(BACnetType::BOOLEAN, 9, self.notifyType_raw.tag);
  var fromState: BACnetEventState;
  fromState_raw: BACnetContextMessage(BACnetType::Enumerated, 10, self.ackRequired.tag) { # BACnetEventState, optional
    if ( self.fromState_raw.tag.tag == 10 ) {
      self.fromState = BACnetEventState(self.fromState_raw.unsigned);
    }
  }
  toState_raw: BACnetContextMessage(BACnetType::Enumerated, 11, self.fromState_raw.tag); # BACnetEventState, not optional
#  eventValues: ... if ( len > self.offset() ); # BACnetNotificationParameters, optional # Fixme: we do not handle the BACnetNotificationParameters yet
#
};
#
# Enums to handle bacnetnotificationparameters:
#
# BACnetPropertyStates,
# BACnetLifeSafetyState,
# BACnetLifeSafetyMode,
# BACnetLifeSafetyOperation
# BACnetDeviceObjectPropertyValue
# BACnetDeviceObjectPropertyReference,
# BACnetAccessEvent,
# BACnetStatusFlags,
# BACnetDeviceObjectReference,
# BACnetAuthenticationFactor
# BACnetReliability,

type AtomicReadFile_Request = unit(invokeID: uint8) {
  fileIdentifier: BACnetMessage; # oid
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
    fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
    requestedOctetCount: BACnetMessage if ( self.open_tag.tag == 0 ); # unsigned

  # recordAccess
    fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
    requestedRecordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
  # close tag
   : BACnetTag;
};

type AtomicWriteFile_Request = unit {
  fileIdentifier: BACnetMessage; # oid
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
    fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
    FileData: BACnetMessage if ( self.open_tag.tag == 0 ); # octet string

  # recordAccess
    fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
    recordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
  # sequence of octet string
    fileRecordData: BACnetArray if ( self.open_tag.tag == 1 );
  # close Tag
   : BACnetTag;
};

type ReadProperty_Request = unit(len: uint16, invokeID: uint8) {
  # context-specific tags 0 - 2
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag;
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag) if ( len > self.offset() );
};

type WriteProperty_Request = unit(len: uint16) {
  # context-specific tags 0 - 4
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag; # tag 1
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag);
  propertyValue_tag: BACnetTag if ( self.propertyArrayIndex.tag.tag != 3 ); # check if previous tag was optional. This tag = 3
  propertyValue: BACnetArray_Partial(3);
  bacnet-priority: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.first_tag) if ( len > self.offset() );
};

export type BACnetUnconfirmedServiceChoice = enum {
  i-Am = 0,
  i-Have = 1,
  unconfirmedCOVNotification = 2,
  unconfirmedEventNotification = 3,
  unconfirmedPrivateTransfer = 4,
  unconfirmedTextMessage = 5,
  timeSynchronization = 6,
  who-Has = 7,
  who-Is = 8,
  utcTimeSynchronization = 9,
  writeGroup = 10
};

type PDU_unconfirmedRequest = unit(len: uint16) {
  service_choice: uint8 &convert=BACnetUnconfirmedServiceChoice($$);

  switch ( self.service_choice ) {
    BACnetUnconfirmedServiceChoice::i-Am -> i_am: I_Am_Request;
    BACnetUnconfirmedServiceChoice::i-Have -> i_have: I_Have_Request;
    BACnetUnconfirmedServiceChoice::unconfirmedCOVNotification -> unconfirmedCOVNotification: UnconfirmedCOVNotification_Request(len - 2);
#    BACnetUnconfirmedServiceChoice::unconfirmedEventNotification -> unconfirmedEventNotification: PDU_UnconfirmedEventNotification(len - 2);
    BACnetUnconfirmedServiceChoice::unconfirmedPrivateTransfer -> unconfirmedPrivateTransfer: UnconfirmedPrivateTransfer_Request(len - 2);
    BACnetUnconfirmedServiceChoice::who-Is -> who_is: Who_Is_Request(len - 2);
    BACnetUnconfirmedServiceChoice::who-Has -> who_has: Who_Has_Request(len - 2);
    * -> : void; # { print "unhandled unconfirmedconfirmedrequest", self.service_choice; }
  };
};

type I_Have_Request = unit {
  # Accorting to spec, all elements must be present
  deviceIdentifier: BACnetMessage;
  objectIdentifier: BACnetMessage;
  objectName: BACnetMessage;
};

type Who_Is_Request = unit(len: uint16) {
  # Accorting to spec - must be used as a pair. Either both or none of them.
  tag: BACnetTag if ( len > 0 ); # context specific - has to be tag 0
  deviceInstanceRangeLowLimit: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network) if ( len > 0 );
  tag2: BACnetTag if ( len > 0 ); # context specific - has to be tag 1
  deviceInstanceRangeHighLimit: bytes &length=self.tag2.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network) if ( len > 0);
};

type Who_Has_Request = unit(len: uint16) {
  # context specific tags 0 - 3
  first_tag: BACnetTag;
  deviceInstanceRangeLowLimit: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  deviceInstanceRangeHighLimit: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.deviceInstanceRangeLowLimit.tag);
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.deviceInstanceRangeHighLimit.tag);
  objectName: BACnetContextMessage(BACnetType::CharacterString, 3, self.objectIdentifier.tag) if ( len > self.offset() );
};

type I_Am_Request = unit {
  iAmDeviceIdentifier: BACnetMessage; # oid
  maxAPDULengthAccepted: BACnetMessage; # unsigned
  segmentationSupported: BACnetMessage; # BACnetSegmentation
  var vendorID: BACnetVendorIDs;
  vendorID_raw: BACnetMessage { # unsigned16
    self.vendorID = BACnetVendorIDs(self.vendorID_raw.unsigned);
    #print "vendorID i_am_request", self.vendorID;
  }

};

type UnconfirmedPrivateTransfer_Request = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  var vendorID: BACnetVendorIDs;
  vendorID_raw: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag) {
    self.vendorID = BACnetVendorIDs(self.vendorID_raw.unsigned);
    #print "vendorID UnconfirmedPrivateTransfer_Request", self.vendorID;
  }
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID_raw.tag);
  serviceParameters: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type UnconfirmedCOVNotification_Request = unit(len: uint16) {
  # context specific tags 0-4.
  first_tag: BACnetTag;
  subscriberProcessIdentifier: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  initiatingDeviceIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 1, self.subscriberProcessIdentifier.tag);
  monitoredObjectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.initiatingDeviceIdentifier.tag);
  timeRemaining: BACnetContextMessage(BACnetType::UnsignedInteger, 3, self.monitoredObjectIdentifier.tag);
  listOfValues: BACnetArray; # Sequence of BACnetPropertyValue
};

#type PDU_UnconfirmedEventNotification = unit(len: uint16) {
#  : BACnetTag;
#  processIdentifier : uint32;
#  : BACnetTag;
#  initiatingDeviceIdentifier: BACnetObjectIdentifier
#  : BACnetTag;
#  BACnetObjectIdentifier: BACnetObjectIdentifier
#  : BACnetTag;
#  timeStamp: BACnetTimeStamp;
#  notificationClass_tag: BACnetTag;
#  notificationClass: bytes &length=notificationClass_tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
#  : BACnetTag;
#  priority: uint8;
#  : BACnetTag;
#  eventType: BACnetEventType;
#  : BACnetTag;
#  # tag 7 messageText character string optional
#};

type PDU_simpleACK = unit {
  invokeID: uint8;
  service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);
};

# Fixme: we should perhaps not only id by invokeID, but also by IP...
global complexAck_bytes: map<uint8, bytes>; # store the current bytes
global complexAck_status: map<uint8, uint8>; # store the current invokeId to sequence number mapping

type BACnet_ComplexACK_PDU = unit(head_raw: bytes, len: uint16) {
  var len: uint16 = 3;
  var segmentation_status: bool = False;

  head : bitfield(8) {
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head_raw) {
    if ( self.head.segmented-message == 1 ) {
      self.len = self.len + 2;
    }
  }
  invokeID: uint8;
  sequence_number: uint8 if ( self.head.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);

  # Segmentation is by invokeID with increasing sequence numbers (first is 0).
  # If more-follows == 0, we can just re-assemble the packet and parse it in a second
  # step.
  content_bytes: bytes &length=( len - self.len ) if ( self.head.segmented-message == 1 ) {

    # first segment - initialize data structures
    if ( ( self.head.segmented-message == 1 ) && ( self.sequence_number == 0)  ) {
      complexAck_status[self.invokeID] = 0;
      complexAck_bytes[self.invokeID] = self.content_bytes;
      #print "First segment, invokeID", self.invokeID;
    } else if ( ( self.head.segmented-message == 1 ) && ( self.sequence_number > 0 ) ) {
    # segment other than the first.
    # look if we already know the invokeID and the right sequence number is following. Otherwise - abort or
    # ignore
      if ( self.invokeID in complexAck_status ) {
        if ( complexAck_status[self.invokeID] >= self.sequence_number ) {
          # we already have this one, skip...
          #print "Skipped fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", complexAck_status[self.invokeID];
        } else if ( complexAck_status[self.invokeID] == ( self.sequence_number - 1 ) ) {
          # add fragment
          #print "Added fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", complexAck_status[self.invokeID];
          complexAck_status[self.invokeID] = self.sequence_number;
          complexAck_bytes[self.invokeID] = complexAck_bytes[self.invokeID] + self.content_bytes;
          self.content_bytes = complexAck_bytes[self.invokeID];
          self.segmentation_status = True;
          #if ( self.head.more-follows == 0 ) {
          #  print "complex-ack-Last fragment. Final length:", |self.content_bytes|;
          #}
        } else {
          # we missed a fragment. Kill it...
          # Fixme: and output an error or whatever
          #print "Missing fragment, invokeID", self.invokeID, "got", self.sequence_number, "last seen", complexAck_status[self.invokeID];
          delete complexAck_bytes[self.invokeID];
          delete complexAck_status[self.invokeID];
        }
      } else {
        #print "Unknown fragment, invokeID", self.invokeID, "sequence number", self.sequence_number;
      }
    }
  }

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_ACK( self.invokeID );
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_ACK( self.invokeID );
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_ACK;
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_ACK( len - self.len );
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_ACK( len - self.len );
    * -> : void; # { print "unhandled complexAck", self.confirmed_service_choice; } # Fixme: missing cases
  } if ( self.head.more-follows == 0 && self.head.segmented-message == 0 ); # only parse message if we are in single-chunk

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_ACK( self.invokeID ) &parse(self.content_bytes);
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_ACK( self.invokeID ) &parse(self.content_bytes);
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_ACK &parse(self.content_bytes);
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_ACK( cast<uint16>(|self.content_bytes|) ) &parse(self.content_bytes);
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_ACK( cast<uint16>(|self.content_bytes|) ) &parse(self.content_bytes);
    * -> : void; # { print "unhandled complexAck", self.confirmed_service_choice; } # Fixme: missing cases
  } if ( ( self.head.more-follows == 0 ) && ( self.head.segmented-message == 1 ) && ( self.segmentation_status ) ); # only parse message if we are in last chunk and have all data

    : void {
      if ( ( self.head.more-follows == 0 ) && ( self.head.segmented-message == 1 ) && ( self.segmentation_status ) ) {
        #print "Reassembled:", self.invokeID;
        delete complexAck_bytes[self.invokeID];
        delete complexAck_status[self.invokeID];
      }
    }

};

type ReadRange_ACK = unit(len: uint16) {
  # context specific tags 0-6, last optional
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  var propertyIdentifier: BACnetPropertyIdentifier;
  propertyIdentifier_raw: BACnetContextMessage(BACnetType::Enumerated, 1, self.objectIdentifier.tag) {
    self.propertyIdentifier = BACnetPropertyIdentifier(self.propertyIdentifier_raw.unsigned);
  }
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_raw.tag);
  #var resultFlags: BACnetResultFlags;
  resultFlags: BACnetContextMessage(BACnetType::BitString, 3, self.propertyArrayIndex.tag); # Fixme: unparsed (bitstring) {
  #  self.resultFlags = BACnetResultFlags(self.resultFlags_raw.unsigned);
  #}
  itemCount: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.resultFlags.tag);
  itemData: BACnetArray;
  test: uint8;
  firstSequenceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 6, self.itemData.begin) if ( len > self.offset() );
};

type ConfirmedPrivateTransfer_ACK = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  var vendorID: BACnetVendorIDs;
  vendorID_raw: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag) {
    self.vendorID = BACnetVendorIDs(self.vendorID_raw.unsigned);
    #print "vendorID ConfirmedPrivateTransfer_ACK", self.vendorID;
  }
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID_raw.tag);
  resultBlock: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type AtomicReadFile_ACK = unit(invokeID: uint8) {
  endOfFile: BACnetMessage; # boolean
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
    fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
    fileData: BACnetMessage if ( self.open_tag.tag == 0 ); # octet String

  # recordAccess
    fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
    fileRecordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
    # sequence of octet string
    fileRecordData: BACnetArray if ( self.open_tag.tag == 1 );
  # close tag
   : BACnetTag;
};

type AtomicWriteFile_ACK = unit {
  first_tag: BACnetTag;
  fileStartPosition: BACnetContextMessage(BACnetType::Integer, 0, self.first_tag);
  FileStartRecord: BACnetContextMessage(BACnetType::Integer, 0, self.fileStartPosition.tag);
};

type ReadProperty_ACK = unit(invokeID: uint8) {
  # context-specific tags 0 - 3
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag;
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag);
  propertyValue_tag: BACnetTag if ( self.propertyArrayIndex.tag.tag != 3 ); # check if previous tag was optional. This tag = 3
  propertyValue: BACnetArray_Partial(3);
  #on %done { print self.propertyValue.value; }
};

export type BACnetErrorClass = enum {
  device = 0,
  object-error = 1,
  property-error = 2,
  resources = 3,
  security = 4,
  services = 5,
  vt = 6,
  communication = 7
};

export type BACnetErrorCode = enum {
  abort-apdu-too-long = 123,
  abort-application-exceeded-reply-time = 124,
  abort-buffer-overflow = 51,
  abort-insufficient-security = 135,
  abort-invalid-apdu-in-this-state = 52,
  abort-other = 56,
  abort-out-of-resources = 125,
  abort-preempted-by-higher-priority-task = 53,
  abort-proprietary = 55,
  abort-security-error = 136,
  abort-segmentation-not-supported = 54,
  abort-tsm-timeout = 126,
  abort-window-size-out-of-range = 127,
  access-denied = 85,
  addressing-error = 115,
  bad-destination-address = 86,
  bad-destination-device-id = 87,
  bad-signature = 88,
  bad-source-address = 89,
  bad-timestamp = 90,
  busy = 82,
  cannot-use-key = 91,
  cannot-verify-message-id = 92,
  character-set-not-supported = 41,
  communication-disabled = 83,
  configuration-in-progress = 2,
  correct-key-revision = 93,
  cov-subscription-failed = 43,
  datatype-not-supported = 47,
  delete-fdt-entry-failed = 120,
  device-busy = 3,
  destination-device-id-required = 94,
  distribute-broadcast-failed = 121,
  duplicate-message = 95,
  duplicate-name = 48,
  duplicate-object-id = 49,
  dynamic-creation-not-supported = 4,
  encryption-not-configured = 96,
  encryption-required = 97,
  file-access-denied = 5,
  file-full = 128,
  inconsistent-configuration = 129,
  inconsistent-object-type = 130,
  inconsistent-parameters = 7,
  inconsistent-selection-criterion = 8,
  incorrect-key = 98,
  internal-error = 131,
  invalid-array-index = 42,
  invalid-configuration-data = 46,
  invalid-data-type = 9,
  invalid-event-state = 73,
  invalid-file-access-method = 10,
  invalid-file-start-position = 11,
  invalid-key-data = 99,
  invalid-parameter-data-type = 13,
  invalid-tag = 57,
  invalid-time-stamp = 14,
  key-update-in-progress = 100,
  list-element-not-found = 81,
  log-buffer-full = 75,
  logged-value-purged = 76,
  malformed-message = 101,
  message-too-long = 113,
  missing-required-parameter = 16,
  network-down = 58,
  no-alarm-configured = 74,
  no-objects-of-specified-type = 17,
  no-property-specified = 77,
  no-space-for-object = 18,
  no-space-to-add-list-element = 19,
  no-space-to-write-property = 20,
  no-vt-sessions-available = 21,
  not-configured = 132,
  not-configured-for-triggered-logging = 78,
  not-cov-property = 44,
  not-key-server = 102,
  not-router-to-dnet = 110,
  object-deletion-not-permitted = 23,
  object-identifier-already-exists = 24,
  other = 0,
  operational-problem = 25,
  optional-functionality-not-supported = 45,
  out-of-memory = 133,
  parameter-out-of-range = 80,
  password-failure = 26,
  property-is-not-a-list = 22,
  property-is-not-an-array = 50,
  read-access-denied = 27,
  read-bdt-failed = 117,
  read-fdt-failed = 119,
  register-foreign-device-failed = 118,
  reject-buffer-overflow = 59,
  reject-inconsistent-parameters = 60,
  reject-invalid-parameter-data-type = 61,
  reject-invalid-tag = 62,
  reject-missing-required-parameter = 63,
  reject-parameter-out-of-range = 64,
  reject-too-many-arguments = 65,
  reject-undefined-enumeration = 66,
  reject-unrecognized-service = 67,
  reject-proprietary = 68,
  reject-other = 69,
  router-busy = 111,
  security-error = 114,
  security-not-configured = 103,
  service-request-denied = 29,
  source-security-required = 104,
  success = 84,
  timeout = 30,
  too-many-keys = 105,
  unknown-authentication-type = 106,
  unknown-device = 70,
  unknown-file-size = 122,
  unknown-key = 107,
  unknown-key-revision = 108,
  unknown-network-message = 112,
  unknown-object = 31,
  unknown-property = 32,
  unknown-subscription = 79,
  unknown-route = 71,
  unknown-source-message = 109,
  unknown-vt-class = 34,
  unknown-vt-session = 35,
  unsupported-object-type = 36,
  value-not-initialized = 72,
  value-out-of-range = 37,
  value-too-long = 134,
  vt-session-already-closed = 38,
  vt-session-termination-failure = 39,
  write-access-denied = 40,
  write-bdt-failed = 116
};

type PDU_error = unit {
  invokeID: uint8;
  service: uint8 &convert=BACnetConfirmedServiceChoice($$);
  error-class_tag: BACnetTag;
  error-class: bytes &length=self.error-class_tag.lvt &convert=BACnetErrorClass($$.to_uint(BinPAC::ByteOrder::Network));
  error-code_tag: BACnetTag;
  error-code: bytes &length=self.error-code_tag.lvt &convert=BACnetErrorCode($$.to_uint(BinPAC::ByteOrder::Network));
};

export type BACnetRejectReason = enum {
  other = 0,
  buffer-overflow = 1,
  inconsistent-parameters = 2,
  invalid-parameter-data-type = 3,
  invalid-tag = 4,
  missing-required-parameter = 5,
  parameter-out-of-range = 6,
  too-many-arguments = 7,
  undefined-enumeration = 8,
  unrecognized-service = 9
};

type PDU_reject = unit {
  invokeID: uint8;
  # FIXME: might be preceeded by tag. Need traffic containing it...
  reject_reason: uint8 &convert=BACnetAbortReason($$);
};

export type BACnetAbortReason = enum {
  other = 0,
  buffer-overflow = 1,
  invalid-apdu-in-this-state = 2,
  preempted-by-higher-priority-task = 3,
  segmentation-not-supported = 4,
  security-error = 5,
  insufficient-security = 6,
  window-size-out-of-range = 7,
  application-exceeded-reply-time = 8,
  out-of-resources = 9,
  tsm-timeout = 10,
  apdu-too-long = 11
};

type PDU_abort = unit(head_raw: bytes) { # page 624
  head : bitfield(8) {
    server: 0;
    tpe: 4..7;
  } &parse(head_raw);
  invokeID: uint8;
  # FIXME: might be preceeded by tag. Need traffic containing it...
  abort_reason: uint8 &convert=BACnetAbortReason($$); # pg. 652
};

type ASN1Class = enum {
  UNIVERSAL = 0,
  APPLICATION = 1,
  context-specific = 2,
  PRIVATE = 3
};

type BACnetType = enum {
  NULL = 0,
  BOOLEAN = 1,
  UnsignedInteger = 2,
  Integer = 3,
  Real = 4,
  Double = 5,
  OctetString = 6,
  CharacterString = 7,
  BitString = 8,
  Enumerated = 9,
  Date = 10,
  Time = 11,
  BACnetObjectIdentifier = 12
};

type BACnetTag = unit {
  var tpe: BACnetType;
  var class: ASN1Class;

  data : bitfield(8) {
     lvt: 0..2;
     class: 3;
     tag: 4..7;
  } &bitorder=BinPAC::BitOrder::LSB0;

  tag: uint8 if ( self.data.tag == 0xF );
  lvt: uint8 if ( self.data.lvt == 0x5 );
  # length/value/type.
  # for context-specific, a length of 6 means an open tag, a length of 7 means
  # a close-tag.
  # The close tag needs to be context-specific too and have the same tag-value
  # as the opening tag.

  on %done {
    if ( self.data.tag != 0xF ) {
      self.tag = self.data.tag;
    }
    if ( self.data.lvt != 0x5 ) {
      self.lvt = self.data.lvt;
    }
    self.tpe = BACnetType(self.tag);
    self.class = ASN1Class(self.data.class + 1); # bacnet only has application / context-specific
  }
};

# This is a unit to make my live when parsing bacnet a little bit easier.
# In many cases, we have a number of context-specific tags, of which a few are optional.
# When a tag is optional, the next tag is only parsed when the optional tag was present, otherwhise
# it basically is skipped. This unit is used for the tag _after_ an optional tag.
# If the tag number of the passed(previous) tag is the tag-number of this tag, it returns the old
# tag again. Otherwhise it reads the tag from the wire.
# type OptionalBACnetTag = unit(tag: BACnetTag, expect: uint8) {
#  var tag: BACnetTag;
#
#  tag_raw: BACnetTag if ( tag.tag != expect );
#
#  on %done {
#    if ( tag != expect ) {
#      self.tag = self.tag_raw;
#    } else {
#      self.tag = tag;
#    }
#  }
#};

type BACnetArray_Partial = unit(tag: uint8) { # BACnetArray without the beginning tag (we alrady read that)
  # start tag of the array.
  # Fixme: bail out if the tag is not context-specific
  # Fixme: bail out if self.begin.lvt != 6
  #begin: BACnetTag;
  value: list<BACnetMessage> &until( ( $$.tag.class == ASN1Class::context-specific ) &&
                                     ( $$.tag.lvt == 7 ) &&
                                     ( $$.tag.tag == tag ) );
};

type BACnetArray = unit { #
  # start tag of the array.
  # Fixme: bail out if the tag is not context-specific
  # Fixme: bail out if self.begin.lvt != 6
  begin: BACnetTag;
  value: list<BACnetMessage> &until( ( $$.tag.class == ASN1Class::context-specific ) &&
                                     ( $$.tag.lvt == 7 ) &&
                                     ( $$.tag.tag == self.begin.tag ) );
};

export type BACnetObjectType = enum {
  alert-enrollment = 52,
  access-credential = 32,
  access-door = 30,
  access-point = 33,
  access-rights = 34,
  access-user = 35,
  access-zone = 36,
  accumulator = 23,
  analog-input = 0,
  analog-output = 1,
  analog-value = 2,
  averaging = 18,
  binary-input = 3,
  binary-output = 4,
  binary-value = 5,
  bitstring-value = 39,
  calendar = 6,
  channel = 53,
  characterstring-value = 40,
  command = 7,
  credential-data-input = 37,
  date-pattern-value = 41,
  date-value = 42,
  datetime-pattern-value = 43,
  datetime-value = 44,
  device = 8,
  event-enrollment = 9,
  event-log = 25,
  bacnet-file = 10,  # original name: file
  global-group = 26,
  group = 11,
  integer-value = 45,
  large-analog-value = 46,
  life-safety-point = 21,
  life-safety-zone = 22,
  lighting-output = 54,
  load-control = 28,
  loop = 12,
  multi-state-input = 13,
  multi-state-output = 14,
  multi-state-value = 19,
  network-security = 38,
  notification-class = 15,
  notification-forwarder = 51,
  octetstring-value = 47,
  positive-integer-value = 48,
  program = 16,
  pulse-converter = 24,
  schedule = 17,
  structured-view = 29,
  time-pattern-value = 49,
  time-value = 50,
  trend-log = 20,
  trend-log-multiple = 27
};

# Fixme: need to get the type mapping from somewhere, probably the standard...
type BACnetObjectIdentifier = unit {
  var tpe: BACnetObjectType;

  data: bitfield(32) {
    instanceNumber: 0..21;
    tpe: 22..31;
  } {
    self.tpe = BACnetObjectType(self.data.tpe);
  }
};

type BACnetMessage = unit {
  tag: BACnetTag;

  var boolean: bool;
  var bool_val: uint16;

  switch ( self.tag.tpe ) {
    BACnetType::NULL -> : void;
    BACnetType::BOOLEAN -> : void {
      self.bool_val = self.tag.lvt;
      self.boolean = self.bool_val == 0 ? False : True;

    }
    BACnetType::UnsignedInteger,
    BACnetType::Enumerated -> unsigned: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
    BACnetType::Integer -> signed: bytes &length=self.tag.lvt &convert=$$.to_int(BinPAC::ByteOrder::Network);
    BACnetType::OctetString -> octets: bytes &length=self.tag.lvt;
    BACnetType::CharacterString -> characters: BACnetCharacterString(self.tag.lvt);
    BACnetType::BitString -> bitstring: BACnetBitString(self.tag.lvt);
    BACnetType::Date -> date: BACnetDate;
    BACnetType::Time -> btime: BACnetTime;
    BACnetType::BACnetObjectIdentifier -> oid: BACnetObjectIdentifier;

    # Fixme: Real, double. I don't think Binpac++ can read those from wire yet.
    BACnetType::Real -> realval: bytes &length = 4;
    BACnetType::Double -> doubleval: bytes &length = 8;
  } if ( self.tag.class == ASN1Class::APPLICATION);
  # skip parsing if we do not have an application tag. Usually, this should only happen when we are parsing
  # arrays. There the last tag will be context-specific and we use it to abort.
};

# This basically is a plain copy of the unit from above. Once I get default arguments, it will be easy to get
# rid of this :)
# tpe: type we expect
# tag: tag number we expect. If this does not match, skip
# prev_tag: the previous tag. If the tag number we expect matches the previous tag, take the previous tag.
# Assume correct ordering of tags. I think we always have that in BACnet...
type BACnetContextMessage = unit(tpe: BACnetType, tag: uint8, prev_tag: BACnetTag) {
  var tag: BACnetTag;

  tag_new: BACnetTag if ( prev_tag.tag < tag ); # only if the old tag does not match what we want.

  : void { # sorry, abusing void just works too well here :)
    if ( prev_tag.tag < tag ) {
      self.tag = self.tag_new;
    } else {
      self.tag = prev_tag;
    }
  }

  var boolean: bool;
  var bool_val: uint16;

  switch ( tpe ) {
    BACnetType::NULL -> : void;
    BACnetType::BOOLEAN -> : void {
      self.bool_val = self.tag.lvt;
      self.boolean = self.bool_val == 0 ? False : True;

    }
    BACnetType::UnsignedInteger,
    BACnetType::Enumerated -> unsigned: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
    BACnetType::Integer -> signed: bytes &length=self.tag.lvt &convert=$$.to_int(BinPAC::ByteOrder::Network);
    BACnetType::OctetString -> octets: bytes &length=self.tag.lvt; # { print self.octets; }
    BACnetType::CharacterString -> characters: BACnetCharacterString(self.tag.lvt); # { print self.characters; }
    BACnetType::BitString -> bistring: BACnetBitString(self.tag.lvt);
    BACnetType::Date -> date: BACnetDate;
    BACnetType::Time -> btime: BACnetTime;
    BACnetType::BACnetObjectIdentifier -> oid: BACnetObjectIdentifier;

    # Fixme: Real, double. I don't think Binpac++ can read those from wire yet.
    BACnetType::Real -> : bytes &length = 4;
    BACnetType::Double -> : bytes &length = 8;
  } if ( self.tag.tag == tag );
  # this check is in case we get optional tags. In this case we may not read the data because it probably will not fit.
};

type BACnetDateTime = unit {
  date: BACnetMessage;
  btime: BACnetMessage;
};

type BACnetTimeStamp = unit {
  # choice
  tag: BACnetTag;

  btime: BACnetTime if ( self.tag.tag == 0 );
  sequenceNumber: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network) if ( self.tag.tag == 1);
  dateTime: BACnetDateTime if ( self.tag.tag == 2 );

  : BACnetTag if ( self.tag.lvt == 6 );
};

type BACnetDate = unit {
  # a value of 0xFF in any field means wildcard.

  var year: uint16;
  year_raw: uint8 {
    if ( self.year_raw != 0xFF ) {
      self.year = self.year_raw;
      self.year = self.year + 1900;
    } else {
      self.year = 0; # unspecified
    }
  }

  month: uint8;
  day: uint8;
  weekday: uint8; # monday = 1
};

type BACnetTime = unit {
  # a value of 0xFF in any field means wildcard.
  hour: uint8;
  minute: uint8;
  second: uint8;
  centisecond: uint8;
};

type BACnetCharacterStringType = enum {
  UTF8 = 0,
  DBCS = 1,
  JISX0208 = 2,
  UCS4 = 3,
  UCS2 = 4,
  ISO00591 = 5
};

type BACnetCharacterString = unit(len: uint16) {
  tpe: uint8 &convert=BACnetCharacterStringType($$);

  switch ( self.tpe ) {
    # LE and BE could be switched, not quite sure...
    BACnetCharacterStringType::UTF8 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF8);
    BACnetCharacterStringType::UCS2 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF16BE);
    BACnetCharacterStringType::UCS4 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF32BE);
    * -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::ASCII); # Fixme: DBCS, JOSX0208, ISO885901
  };

};

type BACnetBitString = unit(len: uint16) {
   # We have cases where the length is 0. I do not think this is legal, but...
   unused_bits: uint8 if ( len > 0 );
   value_bits: bytes &length=(len - 1) if ( len > 1 );
};

